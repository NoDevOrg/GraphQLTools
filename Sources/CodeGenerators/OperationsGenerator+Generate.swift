import Foundation
import GraphQL

extension OperationsGenerator {
    public func generate() throws {
        printHeader()
        printImports()
        printLibrary()
        printNamespace()
        printTypeMapping()
        try printOperations()
    }

    func printHeader() {
        println(
            """
            //
            // DO NOT EDIT.
            // swift-format-ignore-file
            //
            // Generated by GraphQLOperationsCodeGen
            //
            """
        )
    }

    func printImports() {
        println()
        println(
            """
            import Foundation
            import GraphQL
            """)
    }

    func printLibrary() {
        println()
        mark("Support")
        println(
            """
            protocol GraphQLOperation: Codable {
                associatedtype Result: Codable

                static var name: String { get }
                static var document: String { get }
            }

            struct GraphQLRequest<Variables: Codable>: Codable {
                let operationName: String
                let query: String
                let variables: Variables
            }

            func encode<Operation: GraphQLOperation>(operation: Operation, encoder: JSONEncoder) throws -> Data {
                try encoder.encode(
                    GraphQLRequest(
                        operationName: Operation.name,
                        query: Operation.document,
                        variables: operation
                ))
            }

            struct GraphQLResponse<Operation: GraphQLOperation>: Codable {
                let data: Operation.Result?
                let errors: [GraphQLError]?
            }

            func decode<Operation: GraphQLOperation>(operation: Operation, data: Data, decoder: JSONDecoder) throws -> GraphQLResponse<Operation> {
                return try decoder.decode(GraphQLResponse<Operation>.self, from: data)
            }
            """
        )
    }

    func printNamespace() {
        println()
        println("enum \(data.namespace) {}")
    }

    func printTypeMapping() {
        guard !options.typeMapping.isEmpty else { return }
        println()
        mark("Type Mapping")
        scoped("extension \(data.namespace)", scope: .curly) {
            for (key, value) in options.typeMapping.sorted(by: { $0.key < $1.key }) {
                println("typealias \(key) = \(value)")
            }
        }
    }

    func printOperations() throws {
        println()
        mark("Operations")
        try scoped("extension \(data.namespace)", scope: .curly) {
            for (operation, file) in data.operationDefinitionAndFile {
                guard let name = operation.name?.value else {
                    throw GeneratorError(description: "All operations must have a name. A \(operation.operation.display) is missing a name.")
                }
                try scoped("struct \(name)\(operation.operation.display): GraphQLOperation", scope: .curly) {
                    println("typealias Result = Data")
                    println()
                    println("static var name: String = \"\(name)\"")
                    println()
                    println("static let document: String = \"\"\"")
                    println(file)
                    println("\"\"\"")
                    println()

                    for variableDefinition in operation.variableDefinitions {
                        println("let \(variableDefinition.variable.name.value): \(try swiftTypeName(variableDefinition.type))")
                    }

                    if !operation.variableDefinitions.isEmpty {
                        println()
                    }

                    switch operation.operation {
                    case .query:
                        try printType(name: "Data", selectionSet: operation.selectionSet, definitions: data.queryFields)
                    case .mutation:
                        try printType(name: "Data", selectionSet: operation.selectionSet, definitions: data.mutationFields)
                    case .subscription:
                        try printType(name: "Data", selectionSet: operation.selectionSet, definitions: data.subscriptionFields)
                    }

                }
            }
        }
    }

    private func printType(name: String, selectionSet: SelectionSet, definitions: [FieldDefinition]) throws {
        try scoped("struct \(name): Codable", scope: .curly) {
            var additionalTypesToGenerate: [String: SelectionSet] = [:]
            for selection in selectionSet.selections {
                guard let field = selection as? Field else {
                    throw GeneratorError(description: "Only fields are supported.")
                }
                guard let type = definitions.first(where: { $0.name.value == field.name.value }) else {
                    throw GeneratorError(description: "Field \(field.name.value) not found.")
                }

                let underlyingName = try underlyingTypeName(type.type)

                if !wellKnownTypes.keys.contains(underlyingName) {
                    additionalTypesToGenerate[underlyingName] = field.selectionSet
                }

                println("let \(field.name.value): \(try swiftTypeName(type.type))")
            }

            if !additionalTypesToGenerate.isEmpty {
                println()
            }

            for (name, selectionSet) in additionalTypesToGenerate {
                let fields = data.schemaDefinitions.objects(named: name).flatMap({ $0.fields })
                try printType(name: name, selectionSet: selectionSet, definitions: fields)
            }
        }
    }
}
