import Foundation
import GraphQL

extension OperationsGenerator {
    public func generate() throws {
        printHeader()
        printImports()
        printLibrary()
        printNamespace()
        printTypeMapping()
        try printEnums()
        try printInputs()
        try printOperations()
    }

    func printHeader() {
        println(
            """
            //
            // DO NOT EDIT.
            // swift-format-ignore-file
            //
            // Generated by GraphQLOperationsCodeGen
            //
            """
        )
    }

    func printImports() {
        println()
        println(
            """
            import Foundation
            import GraphQL
            """)
    }

    func printLibrary() {
        println()
        mark("Support")
        println(
            """
            \(options.visibility) struct GraphQLOperationError: Error {
                let description: String
            }
            
            \(options.visibility) protocol GraphQLOperation: Codable {
                associatedtype Result: Codable

                static var name: String { get }
                static var document: String { get }
            }
            
            extension GraphQLOperation {
                \(options.visibility) func request(encoder: JSONEncoder = JSONEncoder(), decoder: JSONDecoder = JSONDecoder()) throws -> GraphQLRequest {
                    GraphQLRequest(
                        query: Self.document,
                        operationName: Self.name,
                        variables: try decoder.decode([String: Map].self, from: encoder.encode(self))
                    )
                }

                \(options.visibility) static func data(from result: GraphQLResult, encoder: JSONEncoder = JSONEncoder(), decoder: JSONDecoder = JSONDecoder()) throws -> Result {
                    guard let data = result.data else { throw GraphQLOperationError(description: "GraphQL operation \\(Self.name) result missing data") }
                    return try decoder.decode(Result.self, from: encoder.encode(data)) 
                }
            }
            """
        )
    }

    func printNamespace() {
        println()
        println("\(options.visibility) enum \(data.namespace) {}")
    }

    func printTypeMapping() {
        guard !options.typeMapping.isEmpty else { return }
        println()
        mark("Type Mapping")
        scoped("extension \(data.namespace)", scope: .curly) {
            for (key, value) in options.typeMapping.sorted(by: { $0.key < $1.key }) {
                println("\(options.visibility) typealias \(key) = \(value)")
            }
        }
    }

    func printEnums() throws {
        println()
        mark("Enums")
        try scoped("extension \(data.namespace)", scope: .curly) {
            try looped(data.enumsNeeded) { object in
                try scoped("\(options.visibility) enum \(object.name.value): String, Codable", scope: .curly) {
                    for value in object.values {
                        println("case \(value.name.value)")
                    }
                }
            }
        }
    }

    func printInputs() throws {
        println()
        mark("Inputs")
        try scoped("extension \(data.namespace)", scope: .curly) {
            try looped(data.inputsNeeded) { object in
                try scoped("\(options.visibility) struct \(object.name.value): Codable", scope: .curly) {
                    for field in object.fields {
                        println("\(options.visibility) let \(field.name.value): \(try swiftTypeName(field.type))")
                    }
                }
            }
        }
    }

    func printOperations() throws {
        println()
        mark("Operations")
        try scoped("extension \(data.namespace)", scope: .curly) {
            for (operation, file) in data.operationDefinitionAndFile {
                guard let name = operation.name?.value else {
                    throw GeneratorError(description: "All operations must have a name. A \(operation.operation.display) is missing a name.")
                }
                try scoped("\(options.visibility) struct \(name)\(operation.operation.display): GraphQLOperation", scope: .curly) {
                    println("\(options.visibility) typealias Result = Data")
                    println()
                    println("\(options.visibility) static var name: String = \"\(name)\"")
                    println()
                    println("\(options.visibility) static let document: String = \"\"\"")
                    println(file)
                    println("\"\"\"")
                    println()

                    for variableDefinition in operation.variableDefinitions {
                        println("\(options.visibility) let \(variableDefinition.variable.name.value): \(try swiftTypeName(variableDefinition.type))")
                    }

                    if !operation.variableDefinitions.isEmpty {
                        println()
                    }

                    switch operation.operation {
                    case .query:
                        try printType(name: "Data", selectionSet: operation.selectionSet, definitions: data.queryFields)
                    case .mutation:
                        try printType(name: "Data", selectionSet: operation.selectionSet, definitions: data.mutationFields)
                    case .subscription:
                        try printType(name: "Data", selectionSet: operation.selectionSet, definitions: data.subscriptionFields)
                    }

                }
            }
        }
    }

    private func printType(name: String, selectionSet: SelectionSet, definitions: [FieldDefinition]) throws {
        try scoped("\(options.visibility) struct \(name): Codable", scope: .curly) {
            var additionalTypesToGenerate: [String: SelectionSet] = [:]
            for selection in selectionSet.selections {
                guard let field = selection as? Field else {
                    throw GeneratorError(description: "Only fields are supported.")
                }
                guard let type = definitions.first(where: { $0.name.value == field.name.value }) else {
                    throw GeneratorError(description: "Field \(field.name.value) not found.")
                }

                let underlyingName = try underlyingTypeName(type.type)

                if !wellKnownTypes.keys.contains(underlyingName) {
                    additionalTypesToGenerate[underlyingName] = field.selectionSet
                }

                println("\(options.visibility) let \(field.name.value): \(try swiftTypeName(type.type))")
            }

            if !additionalTypesToGenerate.isEmpty {
                println()
            }

            for (name, selectionSet) in additionalTypesToGenerate {
                let fields = data.schemaDefinitions.objects(named: name).flatMap({ $0.fields })
                try printType(name: name, selectionSet: selectionSet, definitions: fields)
            }
        }
    }
}
