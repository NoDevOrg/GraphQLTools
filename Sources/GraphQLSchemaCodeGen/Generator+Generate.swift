import Foundation
import GraphQL

extension Generator {
    func generate() throws {
        printHeader()
        printImports()
        printNamespace()
        printSDL()
        try printObjectTypes()
        try printResolverArguments()
        try printResolverProtocol()
        try printSchemaBuilder()
    }

    func printHeader() {
        println(
        """
        //
        // DO NOT EDIT.
        // swift-format-ignore-file
        //
        // Generated by GraphQLSchemaCodeGen
        //

        """)
    }

    func printImports() {
        println(
        """
        import Foundation
        import GraphQL
        import Graphiti
        """)

        for additionalImport in additionalImports {
            println("import \(additionalImport)")
        }

        println()
    }

    func printNamespace() {
        println("enum \(namespace)Schema {}")
        println()
    }

    func printSDL() {
        mark("SDL")
        scoped("extension \(namespace)Schema", scope: .curly) {
            println("static let sdl: String =")
            println("\"\"\"")
            println(schemas.joined(separator: "\n"), newLine: false)
            println("\"\"\"")
        }
        println()
    }

    // TODO: Support InputObjectTypeDefinition, InputObjectExtensionDefinition and filtering Schema.OperationTypes
    // if another type name is used for Query, Mutation, or Subscription
    func printObjectTypes() throws {
        mark("Types")
        try scoped("extension \(namespace)Schema", scope: .curly) {
            for object in self.objects {
                try scoped("struct \(object.name.value): Codable", scope: .curly) {
                    for field in object.fields {
                        try println("let \(field.name.value): \(swift(field.type))")
                    }

                    let federationKeyDirectives = object.directives.filter { $0.name.value == "key" }

                    if federationKeyDirectives.count == 1 {
                        try printFederationKeyType(object: object, directive: federationKeyDirectives[0])
                    } else {
                        for (index, directive) in federationKeyDirectives.enumerated() {
                            try printFederationKeyType(suffix: "\(index + 1)", object: object, directive: directive)
                        }
                    }
                }
            }
        }
        println()
    }

    func printFederationKeyType(suffix: String = "", object: ObjectTypeDefinition, directive: Directive) throws {
        guard
            directive.arguments.count == 1,
            let argument = directive.arguments.first,
            argument.name.value == "fields",
            let value = (argument.value as? StringValue)?.value
        else { throw GeneratorError(description: "Key directive does not fields argument") }

        guard
            !value.contains("{"),
            !value.contains("}")
        else { throw GeneratorError(description: "Nested keys are not supported") }
        
        let fields = value.split(separator: " ")
        guard !fields.isEmpty else {
            throw GeneratorError(description: "Key directive fields is empty")
        }

        println()
        try scoped("struct Key\(suffix): Codable", scope: .curly) {
            for field in fields {
                guard let objectField = object.fields.first(where: { $0.name.value == field }) else {
                    throw GeneratorError(description: "\(field) not found in object \(object.name.value)")
                }
                try println("let \(objectField.name.value): \(swift(objectField.type))")
            }
        }

    }

    func printResolverArguments() throws {
        mark("Resolver Arguments")
        try scoped("extension \(namespace)Schema", scope: .curly) {
            try looped(allResolverFields) { field in
                try scoped("struct \(field.name.value.capitalizeFirst)Arguments: Codable", scope: .curly) {
                     for argument in field.arguments {
                         try println("let \(argument.name.value): \(swift(argument.type))")
                     }
                 }
            }
        }
        println()
    }

    func printResolverProtocol() throws {
        mark("Resolver Protocol")
        try scoped("protocol \(namespace)Resolver", scope: .curly) {
            for field in (queryResolverFields + mutationResolverFields) {
                try println("func \(field.name.value)(context: Context, args: \(namespace)Schema.\(field.name.value.capitalizeFirst)Arguments) async throws -> \(swift(field.type, prefix: "\(namespace)Schema."))")
            }
            for field in subscriptionResolverFields {
                try println("func \(field.name.value)(context: Context, args: \(namespace)Schema.\(field.name.value.capitalizeFirst)Arguments) async throws -> EventStream<\(swift(field.type, prefix: "\(namespace)Schema."))>")
            }
            for (object, keys) in objectsWithFederationKey {
                if keys.count == 1 {
                    println("func \(object.name.value.lowercased())(context: Context, key: \(namespace)Schema.\(object.name.value).Key) async throws -> \(namespace)Schema.\(object.name.value)?")
                } else {
                    for count in 0...keys.count {
                        println("func \(object.name.value.lowercased())(context: Context, key: \(namespace)Schema.\(object.name.value).Key\(count)) async throws -> \(namespace)Schema.\(object.name.value)?")
                    }
                }
            }
        }
        println()
    }

    func printSchemaBuilder() throws {
        mark("Schema Builder")
        try scoped("extension \(namespace)Schema", scope: .curly) {
            try scoped("static func schema<Resolver>(coders: Coders = Coders()) throws -> Schema<Resolver, Context> where Resolver: \(namespace)Resolver", scope: .curly) {
                println("try SchemaBuilder(Resolver.self, Context.self)")
                indent()
                println(".setCoders(to: coders)")
                println(".setFederatedSDL(to: sdl)")
                try printSchemaBuilderTypes()
                printSchemaBuilderQuery()
                printSchemaBuilderMutation()
                try printSchemaBuilderSubscription()
                println(".build()")
                outdent()
            }
        }
    }

    func printSchemaBuilderTypes() throws {
        try scoped(".add", scope: .curly) {
            looped(scalars) { scalar in
                println("Scalar(\(scalar.name.value).self, as: \"\(scalar.name.value)\")")
                if let description = scalar.description {
                    indent()
                    println(".description(\"\(description.value)\")")
                    outdent()
                }
            }
            println()
            try looped(objects) { object in
                scoped("Type(\(object.name.value).self, as: \"\(object.name.value)\")", scope: .curly) {
                    for field in object.fields {
                        println("Field(\"\(field.name.value)\", at: \\.\(field.name.value))")
                    }
                }
                for directive in object.directives.filter({ $0.name.value == "key" }) {
                    try scoped(".key(at: Resolver.\(object.name.value.lowercased()))", scope: .curly) {
                        guard let arguments = directive.arguments.first( where: { $0.name.value == "fields" })?.value as? StringValue else {
                            throw GeneratorError(description: "Key has no argument value")
                        }
                        let fields = arguments.value.split(separator: " ")
                        for field in fields {
                            println("Argument(\"\(field)\", at: \\.\(field))")
                        }
                    }
                }
            }
        }
    }

    func printSchemaBuilderQuery() {
        scoped(".addQuery", scope: .curly) {
            for field in queryResolverFields {
                if field.arguments.isEmpty {
                    println("Field(\"\(field.name.value)\", at: Resolver.\(field.name.value))")
                } else {
                    scoped("Field(\"\(field.name.value)\", at: Resolver.\(field.name.value))", scope: .curly) {
                        for argument in field.arguments {
                            println("Argument(\"\(argument.name.value)\", at: \\.\(argument.name.value))")
                        }
                    }
                }
            }
        }
    }
    
    func printSchemaBuilderMutation() {
        scoped(".addMutation", scope: .curly) {
            for field in mutationResolverFields {
                if field.arguments.isEmpty {
                    println("Field(\"\(field.name.value)\", at: Resolver.\(field.name.value))")
                } else {
                    scoped("Field(\"\(field.name.value)\", at: Resolver.\(field.name.value))", scope: .curly) {
                        for argument in field.arguments {
                            println("Argument(\"\(argument.name.value)\", at: \\.\(argument.name.value))")
                        }
                    }
                }
            }
        }
    }

    func printSchemaBuilderSubscription() throws {
        try scoped(".addSubscription", scope: .curly) {
            for field in subscriptionResolverFields {
                if field.arguments.isEmpty {
                    try println("SubscriptionField(\"\(field.name.value)\", as: \(swift(field.type)).self, atSub: Resolver.\(field.name.value))")
                } else {
                    try scoped("SubscriptionField(\"\(field.name.value)\", as: \(swift(field.type)).self, atSub: Resolver.\(field.name.value))", scope: .curly) {
                        for argument in field.arguments {
                            println("Argument(\"\(argument.name.value)\", at: \\.\(argument.name.value))")
                        }
                    }
                }
            }
        }
    }
}
