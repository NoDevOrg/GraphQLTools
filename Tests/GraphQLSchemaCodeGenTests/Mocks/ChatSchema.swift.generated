//
// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by GraphQLSchemaCodeGen
//

import Foundation
import GraphQL
import Graphiti
import Pioneer

enum ChatSchema {}

// MARK: - Error
struct ChatSchemaError: Error {
  let description: String
}

// MARK: - SDL
extension ChatSchema {
  static let sdl: String =
  """
  "ISO8601 Formatted"
  scalar DateTime
  scalar ID

  type Message @key(fields: "id") {
      id: ID!
      body: String!
      recieved: DateTime!
      sender: Sender!
  }

  type System {
      id: ID!
  }

  type User {
      id: ID!
  }

  union Sender = System | User

  type Query {
      history(room: String!): [Message!]!
  }

  type Mutation {
      sendMessage(room: String!, message: String!): Message!
  }

  type Subscription {
      messages(room: String!): Message!
  }

  extend schema @link(url: "https://specs.apollo.dev/federation/v2.0", import: [])
  """
}

// MARK: - Type Mapping
extension ChatSchema {
  typealias DateTime = Foundation.Date
}

// MARK: - Types
extension ChatSchema {
  struct Message: Codable, Sendable {
    let id: ID
    let body: String
    let recieved: DateTime
    let sender: Sender

    var sender_resolver: SenderUnion {
      switch sender {
      case .system(let object): return object
      case .user(let object): return object
      }
    }

    struct Key: Codable, Sendable {
      let id: ID
    }
  }

  struct System: SenderUnion, Codable, Sendable {
    let id: ID
  }

  struct User: SenderUnion, Codable, Sendable {
    let id: ID
  }

  protocol SenderUnion: Codable, Sendable {}

  enum Sender: Codable, Sendable {
    case system(System)
    case user(User)

    func encode(to encoder: any Encoder) throws {
      switch self {
      case .system(let object): try object.encode(to: encoder)
      case .user(let object): try object.encode(to: encoder)
      }
    }

    init(from decoder: any Decoder) throws {
      throw ChatSchemaError(description: "Unable to decode Sender because Unions are not supported as inputs.")
    }
  }
}

// MARK: - Resolver Arguments
extension ChatSchema {
  struct HistoryArguments: Codable, Sendable {
    let room: String
  }

  struct SendMessageArguments: Codable, Sendable {
    let room: String
    let message: String
  }

  struct MessagesArguments: Codable, Sendable {
    let room: String
  }
}

// MARK: - Resolver Protocol
extension ChatSchema {
  protocol ChatResolver: Sendable {
    associatedtype ContextType

    func history(context: ContextType, args: HistoryArguments) async throws -> [Message]
    func sendMessage(context: ContextType, args: SendMessageArguments) async throws -> Message
    func messages(context: ContextType, args: MessagesArguments) async throws -> EventStream<Message>
    func message(context: ContextType, key: Message.Key) async throws -> Message?
  }
}

// MARK: - Resolver Default Implemention
extension ChatSchema.ChatResolver {
  func history(context: ContextType, args: ChatSchema.HistoryArguments) async throws -> [ChatSchema.Message] {
    throw ChatSchemaError(description: "Resolver for query.history is unimplemented.")
  }

  func sendMessage(context: ContextType, args: ChatSchema.SendMessageArguments) async throws -> ChatSchema.Message {
    throw ChatSchemaError(description: "Resolver for mutation.sendMessage is unimplemented.")
  }

  func messages(context: ContextType, args: ChatSchema.MessagesArguments) async throws -> EventStream<ChatSchema.Message> {
    throw ChatSchemaError(description: "Resolver for subscription.messages is unimplemented.")
  }

  func message(context: ContextType, key: ChatSchema.Message.Key) async throws -> ChatSchema.Message? {
    throw ChatSchemaError(description: "Resolver for federation.Message.Key is unimplemented.")
  }
}

// MARK: - Schema Builder
extension ChatSchema {
  static func schema<Resolver>(coders: Coders = Coders()) throws -> Schema<Resolver, Resolver.ContextType> where Resolver: ChatResolver {
    try SchemaBuilder(Resolver.self, Resolver.ContextType.self)
      .setCoders(to: coders)
      .setFederatedSDL(to: sdl)
      .add {
        Scalar(DateTime.self, as: "DateTime")
          .description("ISO8601 Formatted")
        Scalar(ID.self, as: "ID")
        Type(Message.self, as: "Message") {
          Field("id", at: \.id)
          Field("body", at: \.body)
          Field("recieved", at: \.recieved)
          Field("sender", at: \.sender_resolver, as: Sender.self)
        }
        .key(at: Resolver.message) {
          Argument("id", at: \.id)
        }
        Type(System.self, as: "System") {
          Field("id", at: \.id)
        }
        Type(User.self, as: "User") {
          Field("id", at: \.id)
        }
        Union(Sender.self, members: [
          System.self,
          User.self,
        ])
      }
      .addQuery {
        Field("history", at: Resolver.history) {
          Argument("room", at: \.room)
        }
      }
      .addMutation {
        Field("sendMessage", at: Resolver.sendMessage) {
          Argument("room", at: \.room)
          Argument("message", at: \.message)
        }
      }
      .addSubscription {
        SubscriptionField("messages", as: Message.self, atSub: Resolver.messages) {
          Argument("room", at: \.room)
        }
      }
      .build()
  }
}
